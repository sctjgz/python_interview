# Redis

## 简单动态字符串(SDS)
* SDS的属性：
    * free属性，表示SDS实例中内部未使用的空间数量
    * len属性，表示SDS实例中的字符串的长度
    * buf属性，是一个char类型的数组，分别按字节保存数据，最后以一个'\0'结尾
* SDS和普通C字符串的区别：
    1. 获取长度的时间损耗区别：
        * C语言用一个N+1的字符串数组表示一个长度为N的字符串。因为不记录自身的长度，所以C语言中获取字符串长度的时间复杂度是O(N).
        * SDS中的len属性记录了自身长度，因此获取长度的复杂度是O(1)。
    2. 缓冲区问题：
        * C语言不记录自身长度，容易造成缓冲区溢出。当执行`strcat`之前，需要为之前的字符串分配足够的空间，否则可能会影响临近空间的数据。
        * SDS会先自动检查长度是否足够，如果不够会自动扩展空间。
    3. 内存重新分配次数：
        * C语言在字符串增长和缩短的情况，都需要对内存重新分配，否则会出现缓冲区溢出和内存泄漏的问题。
        * SDS会通过空间预分配(会分配当前长度*2+1的空间，这时len属性和free属性相同)和惰性空间释放(在字符串缩短时，会先把多出来的空间交给free属性记录)
    4. 二进制安全
        * C语言的字符除了字符串末尾外，不能包含空字符，否则会被程序误认为字符串结尾。
        * SDS的API都是二进制安全的，回忆处理二进制的方式来处理SDS存放在buf数组里的数据。

## 链表
Redis自己构建了链表的实现。列表键的底层实现之一就是链表。

### list结构
* list的属性：
    * head表头指针
    * tail表尾指针
    * len 链表长度计数器
    * dup方法，用于复制链表节点所保存的值
    * free方法，释放链表节点所保存的值
    * match方法，用于对比链表节点所保存的值和另一个输入值是否相等
* Redis的链表特征：
    * 双端：每个节点都有prev和next指针，可以获取前序和后续节点，复杂度都是O(1)
    * 无环：无环链表
    * 带表头指针和表尾指针： 程序获取链表的表头节点和表尾结点的复杂度都是O(1)
    * 带链表长度计数： 获取链表长度的复杂度是O(1)
    * 多态： 链表可以保存不同类型的值

## 字典
* Redis的数据库是使用字典作为底层实现的，增删查改也是构建在对字典的操作之上的。
* 字典还是哈希的底层实现之一，同时也是解决哈希冲突的实现之一
* 字典的属性：
    * table属性：一个数组，每个元素都是一个纸箱`dictEntry`结构的指针，每个`dictEntry`结构都保存着一个键值对。
    * size属性：记录这个哈希表的大小。
    * used属性：记录哈希表目前已有的键值对的数量
    * sizemask： 总是等于`size-1`，这个属性和哈希值一起觉得该放到哪个索引上。
